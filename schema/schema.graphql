# A signed eight-byte integer. The upper big integer values are greater then the
# max value for a JavaScript number. Therefore all big integers will be output as
# strings and not numbers.
scalar BigInt

# A connection to a list of `Category` values.
type CategoriesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Category` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Category` and cursor to aid in pagination.
  edges: [CategoriesEdge]

  # A list of `Category` objects.
  nodes: [Category!]
}

# A `Category` edge in the connection.
type CategoriesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Category` at the end of the edge.
  node: Category!
}

# Methods to use when ordering `Category`.
enum CategoriesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  NAME_ASC
  NAME_DESC
  DATA_TYPE_ASC
  DATA_TYPE_DESC
  ID_ASC
  ID_DESC
}

type Category implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  name: String!
  dataType: String
  id: Uuid

  # Reads a single `DataType` that is related to this `Category`.
  dataTypeByDataType: DataType

  # Reads and enables paginatation through a set of `Object`.
  objectsByCategory(
    # The method to use when ordering `Object`.
    orderBy: ObjectsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ObjectCondition
  ): ObjectsConnection
}

# A connection to a list of `Category` values.
type CategoryByDataTypeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Category` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Category` and cursor to aid in pagination.
  edges: [CategoryByDataTypeEdge]

  # A list of `Category` objects.
  nodes: [Category]
}

# A `Category` edge in the connection.
type CategoryByDataTypeEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Category` at the end of the edge.
  node: Category
}

# Methods to use when ordering `Category`.
enum CategoryByDataTypeOrderBy {
  NATURAL
}

# A condition to be used against `Category` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input CategoryCondition {
  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `dataType` field.
  dataType: String

  # Checks for equality with the object’s `id` field.
  id: Uuid
}

input CategoryInput {
  name: String!
  dataType: String
  id: Uuid
}

# Represents an update to a `Category`. Fields that are set will be updated.
input CategoryPatch {
  name: String
  dataType: String
  id: Uuid
}

# All input for the `createCategory` mutation.
input CreateCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Category` to be created by this mutation.
  category: CategoryInput!
}

# The output of our `createCategory` mutation.
type CreateCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Category` that was created by this mutation.
  category: Category

  # An edge for our `Category`. May be used by Relay 1.
  categoryEdge(
    # The method to use when ordering `Category`.
    orderBy: CategoriesOrderBy = PRIMARY_KEY_ASC
  ): CategoriesEdge

  # Reads a single `DataType` that is related to this `Category`.
  dataTypeByDataType: DataType

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createDataType` mutation.
input CreateDataTypeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `DataType` to be created by this mutation.
  dataType: DataTypeInput!
}

# The output of our `createDataType` mutation.
type CreateDataTypePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `DataType` that was created by this mutation.
  dataType: DataType

  # An edge for our `DataType`. May be used by Relay 1.
  dataTypeEdge(
    # The method to use when ordering `DataType`.
    orderBy: DataTypesOrderBy = PRIMARY_KEY_ASC
  ): DataTypesEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createObject` mutation.
input CreateObjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Object` to be created by this mutation.
  object: ObjectInput!
}

# The output of our `createObject` mutation.
type CreateObjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Object` that was created by this mutation.
  object: Object

  # An edge for our `Object`. May be used by Relay 1.
  objectEdge(
    # The method to use when ordering `Object`.
    orderBy: ObjectsOrderBy = PRIMARY_KEY_ASC
  ): ObjectsEdge

  # Reads a single `Taxonomy` that is related to this `Object`.
  taxonomyByTaxonomyId: Taxonomy

  # Reads a single `Object` that is related to this `Object`.
  objectByParentId: Object

  # Reads a single `Category` that is related to this `Object`.
  categoryByCategory: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createOrganization` mutation.
input CreateOrganizationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Organization` to be created by this mutation.
  organization: OrganizationInput!
}

# The output of our `createOrganization` mutation.
type CreateOrganizationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Organization` that was created by this mutation.
  organization: Organization

  # An edge for our `Organization`. May be used by Relay 1.
  organizationEdge(
    # The method to use when ordering `Organization`.
    orderBy: OrganizationsOrderBy = PRIMARY_KEY_ASC
  ): OrganizationsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createOrganizationUser` mutation.
input CreateOrganizationUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `OrganizationUser` to be created by this mutation.
  organizationUser: OrganizationUserInput!
}

# The output of our `createOrganizationUser` mutation.
type CreateOrganizationUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `OrganizationUser` that was created by this mutation.
  organizationUser: OrganizationUser

  # An edge for our `OrganizationUser`. May be used by Relay 1.
  organizationUserEdge(
    # The method to use when ordering `OrganizationUser`.
    orderBy: OrganizationUsersOrderBy = PRIMARY_KEY_ASC
  ): OrganizationUsersEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPcoPropertiesByCategory` mutation.
input CreatePcoPropertiesByCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PcoPropertiesByCategory` to be created by this mutation.
  pcoPropertiesByCategory: PcoPropertiesByCategoryInput!
}

# The output of our `createPcoPropertiesByCategory` mutation.
type CreatePcoPropertiesByCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PcoPropertiesByCategory` that was created by this mutation.
  pcoPropertiesByCategory: PcoPropertiesByCategory

  # An edge for our `PcoPropertiesByCategory`. May be used by Relay 1.
  pcoPropertiesByCategoryEdge(
    # The method to use when ordering `PcoPropertiesByCategory`.
    orderBy: PcoPropertiesByCategoriesOrderBy = NATURAL
  ): PcoPropertiesByCategoriesEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPropertyCollection` mutation.
input CreatePropertyCollectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PropertyCollection` to be created by this mutation.
  propertyCollection: PropertyCollectionInput!
}

# All input for the `createPropertyCollectionObject` mutation.
input CreatePropertyCollectionObjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PropertyCollectionObject` to be created by this mutation.
  propertyCollectionObject: PropertyCollectionObjectInput!
}

# The output of our `createPropertyCollectionObject` mutation.
type CreatePropertyCollectionObjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PropertyCollectionObject` that was created by this mutation.
  propertyCollectionObject: PropertyCollectionObject

  # An edge for our `PropertyCollectionObject`. May be used by Relay 1.
  propertyCollectionObjectEdge(
    # The method to use when ordering `PropertyCollectionObject`.
    orderBy: PropertyCollectionObjectsOrderBy = PRIMARY_KEY_ASC
  ): PropertyCollectionObjectsEdge

  # Reads a single `Object` that is related to this `PropertyCollectionObject`.
  objectByObjectId: Object

  # Reads a single `PropertyCollection` that is related to this `PropertyCollectionObject`.
  propertyCollectionByPropertyCollectionId: PropertyCollection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `createPropertyCollection` mutation.
type CreatePropertyCollectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PropertyCollection` that was created by this mutation.
  propertyCollection: PropertyCollection

  # An edge for our `PropertyCollection`. May be used by Relay 1.
  propertyCollectionEdge(
    # The method to use when ordering `PropertyCollection`.
    orderBy: PropertyCollectionsOrderBy = PRIMARY_KEY_ASC
  ): PropertyCollectionsEdge

  # Reads a single `DataType` that is related to this `PropertyCollection`.
  dataTypeByDataType: DataType

  # Reads a single `Organization` that is related to this `PropertyCollection`.
  organizationByOrganizationId: Organization

  # Reads a single `User` that is related to this `PropertyCollection`.
  userByImportedBy: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createRelation` mutation.
input CreateRelationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Relation` to be created by this mutation.
  relation: RelationInput!
}

# The output of our `createRelation` mutation.
type CreateRelationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Relation` that was created by this mutation.
  relation: Relation

  # An edge for our `Relation`. May be used by Relay 1.
  relationEdge(
    # The method to use when ordering `Relation`.
    orderBy: RelationsOrderBy = PRIMARY_KEY_ASC
  ): RelationsEdge

  # Reads a single `PropertyCollection` that is related to this `Relation`.
  propertyCollectionByPropertyCollectionId: PropertyCollection

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectIdRelation: Object

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createRole` mutation.
input CreateRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Role` to be created by this mutation.
  role: RoleInput!
}

# The output of our `createRole` mutation.
type CreateRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Role` that was created by this mutation.
  role: Role

  # An edge for our `Role`. May be used by Relay 1.
  roleEdge(
    # The method to use when ordering `Role`.
    orderBy: RolesOrderBy = PRIMARY_KEY_ASC
  ): RolesEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createSynonym` mutation.
input CreateSynonymInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Synonym` to be created by this mutation.
  synonym: SynonymInput!
}

# The output of our `createSynonym` mutation.
type CreateSynonymPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Synonym` that was created by this mutation.
  synonym: Synonym

  # An edge for our `Synonym`. May be used by Relay 1.
  synonymEdge(
    # The method to use when ordering `Synonym`.
    orderBy: SynonymsOrderBy = PRIMARY_KEY_ASC
  ): SynonymsEdge

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectIdSynonym: Object

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createTaxonomy` mutation.
input CreateTaxonomyInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Taxonomy` to be created by this mutation.
  taxonomy: TaxonomyInput!
}

# The output of our `createTaxonomy` mutation.
type CreateTaxonomyPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Taxonomy` that was created by this mutation.
  taxonomy: Taxonomy

  # An edge for our `Taxonomy`. May be used by Relay 1.
  taxonomyEdge(
    # The method to use when ordering `Taxonomy`.
    orderBy: TaxonomiesOrderBy = PRIMARY_KEY_ASC
  ): TaxonomiesEdge

  # Reads a single `Organization` that is related to this `Taxonomy`.
  organizationByOrganizationId: Organization

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createUser` mutation.
input CreateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `User` to be created by this mutation.
  user: UserInput!
}

# The output of our `createUser` mutation.
type CreateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was created by this mutation.
  user: User

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

type DataType implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  name: String!

  # Reads and enables paginatation through a set of `Category`.
  categoriesByDataType(
    # The method to use when ordering `Category`.
    orderBy: CategoriesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: CategoryCondition
  ): CategoriesConnection

  # Reads and enables paginatation through a set of `PropertyCollection`.
  propertyCollectionsByDataType(
    # The method to use when ordering `PropertyCollection`.
    orderBy: PropertyCollectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PropertyCollectionCondition
  ): PropertyCollectionsConnection
}

# A condition to be used against `DataType` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input DataTypeCondition {
  # Checks for equality with the object’s `name` field.
  name: String
}

input DataTypeInput {
  name: String!
}

# Represents an update to a `DataType`. Fields that are set will be updated.
input DataTypePatch {
  name: String
}

# A connection to a list of `DataType` values.
type DataTypesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `DataType` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `DataType` and cursor to aid in pagination.
  edges: [DataTypesEdge]

  # A list of `DataType` objects.
  nodes: [DataType!]
}

# A `DataType` edge in the connection.
type DataTypesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `DataType` at the end of the edge.
  node: DataType!
}

# Methods to use when ordering `DataType`.
enum DataTypesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  NAME_ASC
  NAME_DESC
}

# The day, does not include a time.
scalar Date

# All input for the `deleteCategoryByName` mutation.
input DeleteCategoryByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteCategory` mutation.
input DeleteCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Category` to be deleted.
  nodeId: ID!
}

# The output of our `deleteCategory` mutation.
type DeleteCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  category: Category
  deletedCategoryId: ID

  # Reads a single `DataType` that is related to this `Category`.
  dataTypeByDataType: DataType

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteDataTypeByName` mutation.
input DeleteDataTypeByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteDataType` mutation.
input DeleteDataTypeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `DataType` to be deleted.
  nodeId: ID!
}

# The output of our `deleteDataType` mutation.
type DeleteDataTypePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  dataType: DataType
  deletedDataTypeId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteObjectById` mutation.
input DeleteObjectByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!
}

# All input for the `deleteObject` mutation.
input DeleteObjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Object` to be deleted.
  nodeId: ID!
}

# The output of our `deleteObject` mutation.
type DeleteObjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  object: Object
  deletedObjectId: ID

  # Reads a single `Taxonomy` that is related to this `Object`.
  taxonomyByTaxonomyId: Taxonomy

  # Reads a single `Object` that is related to this `Object`.
  objectByParentId: Object

  # Reads a single `Category` that is related to this `Object`.
  categoryByCategory: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteOrganizationById` mutation.
input DeleteOrganizationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!
}

# All input for the `deleteOrganizationByName` mutation.
input DeleteOrganizationByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteOrganization` mutation.
input DeleteOrganizationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Organization` to be deleted.
  nodeId: ID!
}

# The output of our `deleteOrganization` mutation.
type DeleteOrganizationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  organization: Organization
  deletedOrganizationId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteOrganizationUserByOrganizationIdAndUserIdAndRole` mutation.
input DeleteOrganizationUserByOrganizationIdAndUserIdAndRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  organizationId: Uuid!
  userId: Uuid!
  role: String!
}

# All input for the `deleteOrganizationUser` mutation.
input DeleteOrganizationUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `OrganizationUser` to be deleted.
  nodeId: ID!
}

# The output of our `deleteOrganizationUser` mutation.
type DeleteOrganizationUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  organizationUser: OrganizationUser
  deletedOrganizationUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePropertyCollectionById` mutation.
input DeletePropertyCollectionByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!
}

# All input for the `deletePropertyCollectionByName` mutation.
input DeletePropertyCollectionByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deletePropertyCollection` mutation.
input DeletePropertyCollectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PropertyCollection` to be deleted.
  nodeId: ID!
}

# All input for the `deletePropertyCollectionObjectById` mutation.
input DeletePropertyCollectionObjectByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!
}

# All input for the `deletePropertyCollectionObjectByObjectIdAndPropertyCollectionId` mutation.
input DeletePropertyCollectionObjectByObjectIdAndPropertyCollectionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  objectId: Uuid!
  propertyCollectionId: Uuid!
}

# All input for the `deletePropertyCollectionObject` mutation.
input DeletePropertyCollectionObjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PropertyCollectionObject` to be deleted.
  nodeId: ID!
}

# The output of our `deletePropertyCollectionObject` mutation.
type DeletePropertyCollectionObjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  propertyCollectionObject: PropertyCollectionObject
  deletedPropertyCollectionObjectId: ID

  # Reads a single `Object` that is related to this `PropertyCollectionObject`.
  objectByObjectId: Object

  # Reads a single `PropertyCollection` that is related to this `PropertyCollectionObject`.
  propertyCollectionByPropertyCollectionId: PropertyCollection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `deletePropertyCollection` mutation.
type DeletePropertyCollectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  propertyCollection: PropertyCollection
  deletedPropertyCollectionId: ID

  # Reads a single `DataType` that is related to this `PropertyCollection`.
  dataTypeByDataType: DataType

  # Reads a single `Organization` that is related to this `PropertyCollection`.
  organizationByOrganizationId: Organization

  # Reads a single `User` that is related to this `PropertyCollection`.
  userByImportedBy: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteRelationById` mutation.
input DeleteRelationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!
}

# All input for the `deleteRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationType` mutation.
input DeleteRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationTypeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  propertyCollectionId: Uuid!
  objectId: Uuid!
  objectIdRelation: Uuid!
  relationType: String!
}

# All input for the `deleteRelation` mutation.
input DeleteRelationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Relation` to be deleted.
  nodeId: ID!
}

# The output of our `deleteRelation` mutation.
type DeleteRelationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  relation: Relation
  deletedRelationId: ID

  # Reads a single `PropertyCollection` that is related to this `Relation`.
  propertyCollectionByPropertyCollectionId: PropertyCollection

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectIdRelation: Object

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteRoleByName` mutation.
input DeleteRoleByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteRole` mutation.
input DeleteRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Role` to be deleted.
  nodeId: ID!
}

# The output of our `deleteRole` mutation.
type DeleteRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  role: Role
  deletedRoleId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteSynonymByObjectIdAndObjectIdSynonym` mutation.
input DeleteSynonymByObjectIdAndObjectIdSynonymInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  objectId: Uuid!
  objectIdSynonym: Uuid!
}

# All input for the `deleteSynonym` mutation.
input DeleteSynonymInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Synonym` to be deleted.
  nodeId: ID!
}

# The output of our `deleteSynonym` mutation.
type DeleteSynonymPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  synonym: Synonym
  deletedSynonymId: ID

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectIdSynonym: Object

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteTaxonomyById` mutation.
input DeleteTaxonomyByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!
}

# All input for the `deleteTaxonomyByName` mutation.
input DeleteTaxonomyByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteTaxonomy` mutation.
input DeleteTaxonomyInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Taxonomy` to be deleted.
  nodeId: ID!
}

# The output of our `deleteTaxonomy` mutation.
type DeleteTaxonomyPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  taxonomy: Taxonomy
  deletedTaxonomyId: ID

  # Reads a single `Organization` that is related to this `Taxonomy`.
  organizationByOrganizationId: Organization

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteUserByEmail` mutation.
input DeleteUserByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  email: String!
}

# All input for the `deleteUserById` mutation.
input DeleteUserByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!
}

# All input for the `deleteUserByName` mutation.
input DeleteUserByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteUser` mutation.
input DeleteUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be deleted.
  nodeId: ID!
}

# The output of our `deleteUser` mutation.
type DeleteUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  user: User
  deletedUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar Json

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  # Creates a single `Category`.
  createCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateCategoryInput!
  ): CreateCategoryPayload

  # Updates a single `Category` using its globally unique id and a patch.
  updateCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload

  # Updates a single `Category` using a unique key and a patch.
  updateCategoryByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryByNameInput!
  ): UpdateCategoryPayload

  # Deletes a single `Category` using its globally unique id.
  deleteCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload

  # Deletes a single `Category` using a unique key.
  deleteCategoryByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryByNameInput!
  ): DeleteCategoryPayload

  # Creates a single `DataType`.
  createDataType(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateDataTypeInput!
  ): CreateDataTypePayload

  # Updates a single `DataType` using its globally unique id and a patch.
  updateDataType(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateDataTypeInput!
  ): UpdateDataTypePayload

  # Updates a single `DataType` using a unique key and a patch.
  updateDataTypeByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateDataTypeByNameInput!
  ): UpdateDataTypePayload

  # Deletes a single `DataType` using its globally unique id.
  deleteDataType(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteDataTypeInput!
  ): DeleteDataTypePayload

  # Deletes a single `DataType` using a unique key.
  deleteDataTypeByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteDataTypeByNameInput!
  ): DeleteDataTypePayload

  # Creates a single `Object`.
  createObject(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateObjectInput!
  ): CreateObjectPayload

  # Updates a single `Object` using its globally unique id and a patch.
  updateObject(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateObjectInput!
  ): UpdateObjectPayload

  # Updates a single `Object` using a unique key and a patch.
  updateObjectById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateObjectByIdInput!
  ): UpdateObjectPayload

  # Deletes a single `Object` using its globally unique id.
  deleteObject(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteObjectInput!
  ): DeleteObjectPayload

  # Deletes a single `Object` using a unique key.
  deleteObjectById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteObjectByIdInput!
  ): DeleteObjectPayload

  # Creates a single `Organization`.
  createOrganization(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateOrganizationInput!
  ): CreateOrganizationPayload

  # Updates a single `Organization` using its globally unique id and a patch.
  updateOrganization(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateOrganizationInput!
  ): UpdateOrganizationPayload

  # Updates a single `Organization` using a unique key and a patch.
  updateOrganizationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateOrganizationByIdInput!
  ): UpdateOrganizationPayload

  # Updates a single `Organization` using a unique key and a patch.
  updateOrganizationByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateOrganizationByNameInput!
  ): UpdateOrganizationPayload

  # Deletes a single `Organization` using its globally unique id.
  deleteOrganization(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteOrganizationInput!
  ): DeleteOrganizationPayload

  # Deletes a single `Organization` using a unique key.
  deleteOrganizationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteOrganizationByIdInput!
  ): DeleteOrganizationPayload

  # Deletes a single `Organization` using a unique key.
  deleteOrganizationByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteOrganizationByNameInput!
  ): DeleteOrganizationPayload

  # Creates a single `OrganizationUser`.
  createOrganizationUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateOrganizationUserInput!
  ): CreateOrganizationUserPayload

  # Updates a single `OrganizationUser` using its globally unique id and a patch.
  updateOrganizationUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateOrganizationUserInput!
  ): UpdateOrganizationUserPayload

  # Updates a single `OrganizationUser` using a unique key and a patch.
  updateOrganizationUserByOrganizationIdAndUserIdAndRole(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateOrganizationUserByOrganizationIdAndUserIdAndRoleInput!
  ): UpdateOrganizationUserPayload

  # Deletes a single `OrganizationUser` using its globally unique id.
  deleteOrganizationUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteOrganizationUserInput!
  ): DeleteOrganizationUserPayload

  # Deletes a single `OrganizationUser` using a unique key.
  deleteOrganizationUserByOrganizationIdAndUserIdAndRole(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteOrganizationUserByOrganizationIdAndUserIdAndRoleInput!
  ): DeleteOrganizationUserPayload

  # Creates a single `PcoPropertiesByCategory`.
  createPcoPropertiesByCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePcoPropertiesByCategoryInput!
  ): CreatePcoPropertiesByCategoryPayload

  # Creates a single `PropertyCollection`.
  createPropertyCollection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePropertyCollectionInput!
  ): CreatePropertyCollectionPayload

  # Updates a single `PropertyCollection` using its globally unique id and a patch.
  updatePropertyCollection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePropertyCollectionInput!
  ): UpdatePropertyCollectionPayload

  # Updates a single `PropertyCollection` using a unique key and a patch.
  updatePropertyCollectionById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePropertyCollectionByIdInput!
  ): UpdatePropertyCollectionPayload

  # Updates a single `PropertyCollection` using a unique key and a patch.
  updatePropertyCollectionByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePropertyCollectionByNameInput!
  ): UpdatePropertyCollectionPayload

  # Deletes a single `PropertyCollection` using its globally unique id.
  deletePropertyCollection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePropertyCollectionInput!
  ): DeletePropertyCollectionPayload

  # Deletes a single `PropertyCollection` using a unique key.
  deletePropertyCollectionById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePropertyCollectionByIdInput!
  ): DeletePropertyCollectionPayload

  # Deletes a single `PropertyCollection` using a unique key.
  deletePropertyCollectionByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePropertyCollectionByNameInput!
  ): DeletePropertyCollectionPayload

  # Creates a single `PropertyCollectionObject`.
  createPropertyCollectionObject(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePropertyCollectionObjectInput!
  ): CreatePropertyCollectionObjectPayload

  # Updates a single `PropertyCollectionObject` using its globally unique id and a patch.
  updatePropertyCollectionObject(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePropertyCollectionObjectInput!
  ): UpdatePropertyCollectionObjectPayload

  # Updates a single `PropertyCollectionObject` using a unique key and a patch.
  updatePropertyCollectionObjectById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePropertyCollectionObjectByIdInput!
  ): UpdatePropertyCollectionObjectPayload

  # Updates a single `PropertyCollectionObject` using a unique key and a patch.
  updatePropertyCollectionObjectByObjectIdAndPropertyCollectionId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePropertyCollectionObjectByObjectIdAndPropertyCollectionIdInput!
  ): UpdatePropertyCollectionObjectPayload

  # Deletes a single `PropertyCollectionObject` using its globally unique id.
  deletePropertyCollectionObject(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePropertyCollectionObjectInput!
  ): DeletePropertyCollectionObjectPayload

  # Deletes a single `PropertyCollectionObject` using a unique key.
  deletePropertyCollectionObjectById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePropertyCollectionObjectByIdInput!
  ): DeletePropertyCollectionObjectPayload

  # Deletes a single `PropertyCollectionObject` using a unique key.
  deletePropertyCollectionObjectByObjectIdAndPropertyCollectionId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePropertyCollectionObjectByObjectIdAndPropertyCollectionIdInput!
  ): DeletePropertyCollectionObjectPayload

  # Creates a single `Relation`.
  createRelation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateRelationInput!
  ): CreateRelationPayload

  # Updates a single `Relation` using its globally unique id and a patch.
  updateRelation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateRelationInput!
  ): UpdateRelationPayload

  # Updates a single `Relation` using a unique key and a patch.
  updateRelationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateRelationByIdInput!
  ): UpdateRelationPayload

  # Updates a single `Relation` using a unique key and a patch.
  updateRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationType(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationTypeInput!
  ): UpdateRelationPayload

  # Deletes a single `Relation` using its globally unique id.
  deleteRelation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteRelationInput!
  ): DeleteRelationPayload

  # Deletes a single `Relation` using a unique key.
  deleteRelationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteRelationByIdInput!
  ): DeleteRelationPayload

  # Deletes a single `Relation` using a unique key.
  deleteRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationType(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationTypeInput!
  ): DeleteRelationPayload

  # Creates a single `Role`.
  createRole(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateRoleInput!
  ): CreateRolePayload

  # Updates a single `Role` using its globally unique id and a patch.
  updateRole(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateRoleInput!
  ): UpdateRolePayload

  # Updates a single `Role` using a unique key and a patch.
  updateRoleByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateRoleByNameInput!
  ): UpdateRolePayload

  # Deletes a single `Role` using its globally unique id.
  deleteRole(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteRoleInput!
  ): DeleteRolePayload

  # Deletes a single `Role` using a unique key.
  deleteRoleByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteRoleByNameInput!
  ): DeleteRolePayload

  # Creates a single `Synonym`.
  createSynonym(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateSynonymInput!
  ): CreateSynonymPayload

  # Updates a single `Synonym` using its globally unique id and a patch.
  updateSynonym(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSynonymInput!
  ): UpdateSynonymPayload

  # Updates a single `Synonym` using a unique key and a patch.
  updateSynonymByObjectIdAndObjectIdSynonym(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSynonymByObjectIdAndObjectIdSynonymInput!
  ): UpdateSynonymPayload

  # Deletes a single `Synonym` using its globally unique id.
  deleteSynonym(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSynonymInput!
  ): DeleteSynonymPayload

  # Deletes a single `Synonym` using a unique key.
  deleteSynonymByObjectIdAndObjectIdSynonym(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSynonymByObjectIdAndObjectIdSynonymInput!
  ): DeleteSynonymPayload

  # Creates a single `Taxonomy`.
  createTaxonomy(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateTaxonomyInput!
  ): CreateTaxonomyPayload

  # Updates a single `Taxonomy` using its globally unique id and a patch.
  updateTaxonomy(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTaxonomyInput!
  ): UpdateTaxonomyPayload

  # Updates a single `Taxonomy` using a unique key and a patch.
  updateTaxonomyById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTaxonomyByIdInput!
  ): UpdateTaxonomyPayload

  # Updates a single `Taxonomy` using a unique key and a patch.
  updateTaxonomyByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTaxonomyByNameInput!
  ): UpdateTaxonomyPayload

  # Deletes a single `Taxonomy` using its globally unique id.
  deleteTaxonomy(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTaxonomyInput!
  ): DeleteTaxonomyPayload

  # Deletes a single `Taxonomy` using a unique key.
  deleteTaxonomyById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTaxonomyByIdInput!
  ): DeleteTaxonomyPayload

  # Deletes a single `Taxonomy` using a unique key.
  deleteTaxonomyByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTaxonomyByNameInput!
  ): DeleteTaxonomyPayload

  # Creates a single `User`.
  createUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUserInput!
  ): CreateUserPayload

  # Updates a single `User` using its globally unique id and a patch.
  updateUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByNameInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByEmailInput!
  ): UpdateUserPayload

  # Deletes a single `User` using its globally unique id.
  deleteUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByIdInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByNameInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByEmailInput!
  ): DeleteUserPayload
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
}

type Object implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Uuid!
  taxonomyId: Uuid!
  parentId: Uuid
  name: String!
  properties: Json
  category: String
  idOld: String

  # until postgraphql can filter parent_id null
  level: Int

  # Reads a single `Taxonomy` that is related to this `Object`.
  taxonomyByTaxonomyId: Taxonomy

  # Reads a single `Object` that is related to this `Object`.
  objectByParentId: Object

  # Reads a single `Category` that is related to this `Object`.
  categoryByCategory: Category

  # Reads and enables paginatation through a set of `Object`.
  objectsByParentId(
    # The method to use when ordering `Object`.
    orderBy: ObjectsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ObjectCondition
  ): ObjectsConnection

  # Reads and enables paginatation through a set of `Synonym`.
  synonymsByObjectId(
    # The method to use when ordering `Synonym`.
    orderBy: SynonymsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SynonymCondition
  ): SynonymsConnection

  # Reads and enables paginatation through a set of `Synonym`.
  synonymsByObjectIdSynonym(
    # The method to use when ordering `Synonym`.
    orderBy: SynonymsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SynonymCondition
  ): SynonymsConnection

  # Reads and enables paginatation through a set of `PropertyCollectionObject`.
  propertyCollectionObjectsByObjectId(
    # The method to use when ordering `PropertyCollectionObject`.
    orderBy: PropertyCollectionObjectsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PropertyCollectionObjectCondition
  ): PropertyCollectionObjectsConnection

  # Reads and enables paginatation through a set of `Relation`.
  relationsByObjectId(
    # The method to use when ordering `Relation`.
    orderBy: RelationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: RelationCondition
  ): RelationsConnection

  # Reads and enables paginatation through a set of `Relation`.
  relationsByObjectIdRelation(
    # The method to use when ordering `Relation`.
    orderBy: RelationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: RelationCondition
  ): RelationsConnection
}

# A connection to a list of `Object` values.
type ObjectByObjectNameConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Object` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Object` and cursor to aid in pagination.
  edges: [ObjectByObjectNameEdge]

  # A list of `Object` objects.
  nodes: [Object]
}

# A `Object` edge in the connection.
type ObjectByObjectNameEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Object` at the end of the edge.
  node: Object
}

# Methods to use when ordering `Object`.
enum ObjectByObjectNameOrderBy {
  NATURAL
}

# A condition to be used against `Object` object types. All fields are tested for equality and combined with a logical ‘and.’
input ObjectCondition {
  # Checks for equality with the object’s `id` field.
  id: Uuid

  # Checks for equality with the object’s `taxonomyId` field.
  taxonomyId: Uuid

  # Checks for equality with the object’s `parentId` field.
  parentId: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `properties` field.
  properties: Json

  # Checks for equality with the object’s `category` field.
  category: String

  # Checks for equality with the object’s `idOld` field.
  idOld: String

  # Checks for equality with the object’s `level` field.
  level: Int
}

input ObjectInput {
  id: Uuid
  taxonomyId: Uuid!
  parentId: Uuid
  name: String!
  properties: Json
  category: String
  idOld: String

  # until postgraphql can filter parent_id null
  level: Int
}

# Represents an update to a `Object`. Fields that are set will be updated.
input ObjectPatch {
  id: Uuid
  taxonomyId: Uuid
  parentId: Uuid
  name: String
  properties: Json
  category: String
  idOld: String

  # until postgraphql can filter parent_id null
  level: Int
}

# A connection to a list of `Object` values.
type ObjectsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Object` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Object` and cursor to aid in pagination.
  edges: [ObjectsEdge]

  # A list of `Object` objects.
  nodes: [Object!]
}

# A `Object` edge in the connection.
type ObjectsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Object` at the end of the edge.
  node: Object!
}

# Methods to use when ordering `Object`.
enum ObjectsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  TAXONOMY_ID_ASC
  TAXONOMY_ID_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  NAME_ASC
  NAME_DESC
  PROPERTIES_ASC
  PROPERTIES_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  ID_OLD_ASC
  ID_OLD_DESC
  LEVEL_ASC
  LEVEL_DESC
}

type Organization implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Uuid!
  name: String!

  # Reads and enables paginatation through a set of `Taxonomy`.
  taxonomiesByOrganizationId(
    # The method to use when ordering `Taxonomy`.
    orderBy: TaxonomiesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TaxonomyCondition
  ): TaxonomiesConnection

  # Reads and enables paginatation through a set of `PropertyCollection`.
  propertyCollectionsByOrganizationId(
    # The method to use when ordering `PropertyCollection`.
    orderBy: PropertyCollectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PropertyCollectionCondition
  ): PropertyCollectionsConnection
}

# A condition to be used against `Organization` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input OrganizationCondition {
  # Checks for equality with the object’s `id` field.
  id: Uuid

  # Checks for equality with the object’s `name` field.
  name: String
}

input OrganizationInput {
  id: Uuid
  name: String!
}

# Represents an update to a `Organization`. Fields that are set will be updated.
input OrganizationPatch {
  id: Uuid
  name: String
}

# A connection to a list of `Organization` values.
type OrganizationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Organization` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Organization` and cursor to aid in pagination.
  edges: [OrganizationsEdge]

  # A list of `Organization` objects.
  nodes: [Organization!]
}

# A `Organization` edge in the connection.
type OrganizationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Organization` at the end of the edge.
  node: Organization!
}

# Methods to use when ordering `Organization`.
enum OrganizationsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
}

type OrganizationUser implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  organizationId: Uuid!
  userId: Uuid!
  role: String!
}

# A condition to be used against `OrganizationUser` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input OrganizationUserCondition {
  # Checks for equality with the object’s `organizationId` field.
  organizationId: Uuid

  # Checks for equality with the object’s `userId` field.
  userId: Uuid

  # Checks for equality with the object’s `role` field.
  role: String
}

input OrganizationUserInput {
  organizationId: Uuid!
  userId: Uuid!
  role: String!
}

# Represents an update to a `OrganizationUser`. Fields that are set will be updated.
input OrganizationUserPatch {
  organizationId: Uuid
  userId: Uuid
  role: String
}

# A connection to a list of `OrganizationUser` values.
type OrganizationUsersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `OrganizationUser` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `OrganizationUser` and cursor to aid in pagination.
  edges: [OrganizationUsersEdge]

  # A list of `OrganizationUser` objects.
  nodes: [OrganizationUser!]
}

# A `OrganizationUser` edge in the connection.
type OrganizationUsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `OrganizationUser` at the end of the edge.
  node: OrganizationUser!
}

# Methods to use when ordering `OrganizationUser`.
enum OrganizationUsersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  ROLE_ASC
  ROLE_DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# A connection to a list of `PcoPropertiesByCategory` values.
type PcoPropertiesByCategoriesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PcoPropertiesByCategory` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PcoPropertiesByCategory` and cursor to aid in pagination.
  edges: [PcoPropertiesByCategoriesEdge]

  # A list of `PcoPropertiesByCategory` objects.
  nodes: [PcoPropertiesByCategory!]
}

# A `PcoPropertiesByCategory` edge in the connection.
type PcoPropertiesByCategoriesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PcoPropertiesByCategory` at the end of the edge.
  node: PcoPropertiesByCategory!
}

# A connection to a list of `PcoPropertiesByCategory` values.
type PcoPropertiesByCategoriesFunctionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PcoPropertiesByCategory` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PcoPropertiesByCategory` and cursor to aid in pagination.
  edges: [PcoPropertiesByCategoriesFunctionEdge]

  # A list of `PcoPropertiesByCategory` objects.
  nodes: [PcoPropertiesByCategory]
}

# A `PcoPropertiesByCategory` edge in the connection.
type PcoPropertiesByCategoriesFunctionEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PcoPropertiesByCategory` at the end of the edge.
  node: PcoPropertiesByCategory
}

# Methods to use when ordering `PcoPropertiesByCategory`.
enum PcoPropertiesByCategoriesFunctionOrderBy {
  NATURAL
}

# Methods to use when ordering `PcoPropertiesByCategory`.
enum PcoPropertiesByCategoriesOrderBy {
  NATURAL
  PROPERTY_COLLECTION_NAME_ASC
  PROPERTY_COLLECTION_NAME_DESC
  PROPERTY_NAME_ASC
  PROPERTY_NAME_DESC
  JSONTYPE_ASC
  JSONTYPE_DESC
  COUNT_ASC
  COUNT_DESC
}

type PcoPropertiesByCategory {
  propertyCollectionName: String
  propertyName: String
  jsontype: String
  count: BigInt
}

# A condition to be used against `PcoPropertiesByCategory` object types. All
# fields are tested for equality and combined with a logical ‘and.’
input PcoPropertiesByCategoryCondition {
  # Checks for equality with the object’s `propertyCollectionName` field.
  propertyCollectionName: String

  # Checks for equality with the object’s `propertyName` field.
  propertyName: String

  # Checks for equality with the object’s `jsontype` field.
  jsontype: String

  # Checks for equality with the object’s `count` field.
  count: BigInt
}

input PcoPropertiesByCategoryInput {
  propertyCollectionName: String
  propertyName: String
  jsontype: String
  count: BigInt
}

type PropertyCollection implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Uuid!
  dataType: String
  name: String!
  description: String
  links: [String]
  combining: Boolean
  organizationId: Uuid!
  lastUpdated: Date
  termsOfUse: String
  importedBy: Uuid!

  # Reads a single `DataType` that is related to this `PropertyCollection`.
  dataTypeByDataType: DataType

  # Reads a single `Organization` that is related to this `PropertyCollection`.
  organizationByOrganizationId: Organization

  # Reads a single `User` that is related to this `PropertyCollection`.
  userByImportedBy: User

  # Reads and enables paginatation through a set of `PropertyCollectionObject`.
  propertyCollectionObjectsByPropertyCollectionId(
    # The method to use when ordering `PropertyCollectionObject`.
    orderBy: PropertyCollectionObjectsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PropertyCollectionObjectCondition
  ): PropertyCollectionObjectsConnection

  # Reads and enables paginatation through a set of `Relation`.
  relationsByPropertyCollectionId(
    # The method to use when ordering `Relation`.
    orderBy: RelationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: RelationCondition
  ): RelationsConnection
}

# A connection to a list of `PropertyCollection` values.
type PropertyCollectionByDataTypeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PropertyCollection` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PropertyCollection` and cursor to aid in pagination.
  edges: [PropertyCollectionByDataTypeEdge]

  # A list of `PropertyCollection` objects.
  nodes: [PropertyCollection]
}

# A `PropertyCollection` edge in the connection.
type PropertyCollectionByDataTypeEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PropertyCollection` at the end of the edge.
  node: PropertyCollection
}

# Methods to use when ordering `PropertyCollection`.
enum PropertyCollectionByDataTypeOrderBy {
  NATURAL
}

# A connection to a list of `PropertyCollection` values.
type PropertyCollectionByPropertyNameConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PropertyCollection` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PropertyCollection` and cursor to aid in pagination.
  edges: [PropertyCollectionByPropertyNameEdge]

  # A list of `PropertyCollection` objects.
  nodes: [PropertyCollection]
}

# A `PropertyCollection` edge in the connection.
type PropertyCollectionByPropertyNameEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PropertyCollection` at the end of the edge.
  node: PropertyCollection
}

# Methods to use when ordering `PropertyCollection`.
enum PropertyCollectionByPropertyNameOrderBy {
  NATURAL
}

# A condition to be used against `PropertyCollection` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input PropertyCollectionCondition {
  # Checks for equality with the object’s `id` field.
  id: Uuid

  # Checks for equality with the object’s `dataType` field.
  dataType: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `links` field.
  links: [String]

  # Checks for equality with the object’s `combining` field.
  combining: Boolean

  # Checks for equality with the object’s `organizationId` field.
  organizationId: Uuid

  # Checks for equality with the object’s `lastUpdated` field.
  lastUpdated: Date

  # Checks for equality with the object’s `termsOfUse` field.
  termsOfUse: String

  # Checks for equality with the object’s `importedBy` field.
  importedBy: Uuid
}

input PropertyCollectionInput {
  id: Uuid
  dataType: String
  name: String!
  description: String
  links: [String]
  combining: Boolean
  organizationId: Uuid!
  lastUpdated: Date
  termsOfUse: String
  importedBy: Uuid!
}

type PropertyCollectionObject implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Uuid!
  objectId: Uuid
  propertyCollectionId: Uuid
  properties: Json

  # Reads a single `Object` that is related to this `PropertyCollectionObject`.
  objectByObjectId: Object

  # Reads a single `PropertyCollection` that is related to this `PropertyCollectionObject`.
  propertyCollectionByPropertyCollectionId: PropertyCollection
}

# A condition to be used against `PropertyCollectionObject` object types. All
# fields are tested for equality and combined with a logical ‘and.’
input PropertyCollectionObjectCondition {
  # Checks for equality with the object’s `id` field.
  id: Uuid

  # Checks for equality with the object’s `objectId` field.
  objectId: Uuid

  # Checks for equality with the object’s `propertyCollectionId` field.
  propertyCollectionId: Uuid

  # Checks for equality with the object’s `properties` field.
  properties: Json
}

input PropertyCollectionObjectInput {
  id: Uuid
  objectId: Uuid
  propertyCollectionId: Uuid
  properties: Json
}

# Represents an update to a `PropertyCollectionObject`. Fields that are set will be updated.
input PropertyCollectionObjectPatch {
  id: Uuid
  objectId: Uuid
  propertyCollectionId: Uuid
  properties: Json
}

# A connection to a list of `PropertyCollectionObject` values.
type PropertyCollectionObjectsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PropertyCollectionObject` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PropertyCollectionObject` and cursor to aid in pagination.
  edges: [PropertyCollectionObjectsEdge]

  # A list of `PropertyCollectionObject` objects.
  nodes: [PropertyCollectionObject!]
}

# A `PropertyCollectionObject` edge in the connection.
type PropertyCollectionObjectsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PropertyCollectionObject` at the end of the edge.
  node: PropertyCollectionObject!
}

# Methods to use when ordering `PropertyCollectionObject`.
enum PropertyCollectionObjectsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  OBJECT_ID_ASC
  OBJECT_ID_DESC
  PROPERTY_COLLECTION_ID_ASC
  PROPERTY_COLLECTION_ID_DESC
  PROPERTIES_ASC
  PROPERTIES_DESC
}

# Represents an update to a `PropertyCollection`. Fields that are set will be updated.
input PropertyCollectionPatch {
  id: Uuid
  dataType: String
  name: String
  description: String
  links: [String]
  combining: Boolean
  organizationId: Uuid
  lastUpdated: Date
  termsOfUse: String
  importedBy: Uuid
}

# A connection to a list of `PropertyCollection` values.
type PropertyCollectionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PropertyCollection` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PropertyCollection` and cursor to aid in pagination.
  edges: [PropertyCollectionsEdge]

  # A list of `PropertyCollection` objects.
  nodes: [PropertyCollection!]
}

# A `PropertyCollection` edge in the connection.
type PropertyCollectionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PropertyCollection` at the end of the edge.
  node: PropertyCollection!
}

# Methods to use when ordering `PropertyCollection`.
enum PropertyCollectionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  DATA_TYPE_ASC
  DATA_TYPE_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  LINKS_ASC
  LINKS_DESC
  COMBINING_ASC
  COMBINING_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  LAST_UPDATED_ASC
  LAST_UPDATED_DESC
  TERMS_OF_USE_ASC
  TERMS_OF_USE_DESC
  IMPORTED_BY_ASC
  IMPORTED_BY_DESC
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    nodeId: ID!
  ): Node

  # Reads and enables paginatation through a set of `Category`.
  categoryByDataType(
    # The method to use when ordering `Category`.
    orderBy: CategoryByDataTypeOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    datatype: String
  ): CategoryByDataTypeConnection

  # Reads and enables paginatation through a set of `Object`.
  objectByObjectName(
    # The method to use when ordering `Object`.
    orderBy: ObjectByObjectNameOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    objectName: String
  ): ObjectByObjectNameConnection

  # Reads and enables paginatation through a set of `PcoPropertiesByCategory`.
  pcoPropertiesByCategoriesFunction(
    # The method to use when ordering `PcoPropertiesByCategory`.
    orderBy: PcoPropertiesByCategoriesFunctionOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    categories: [String]
  ): PcoPropertiesByCategoriesFunctionConnection

  # Reads and enables paginatation through a set of `PropertyCollection`.
  propertyCollectionByDataType(
    # The method to use when ordering `PropertyCollection`.
    orderBy: PropertyCollectionByDataTypeOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    datatype: String
  ): PropertyCollectionByDataTypeConnection

  # Reads and enables paginatation through a set of `PropertyCollection`.
  propertyCollectionByPropertyName(
    # The method to use when ordering `PropertyCollection`.
    orderBy: PropertyCollectionByPropertyNameOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    propertyName: String
  ): PropertyCollectionByPropertyNameConnection

  # Reads and enables paginatation through a set of `Category`.
  allCategories(
    # The method to use when ordering `Category`.
    orderBy: CategoriesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: CategoryCondition
  ): CategoriesConnection

  # Reads a single `Category` using its globally unique `ID`.
  category(
    # The globally unique `ID` to be used in selecting a single `Category`.
    nodeId: ID!
  ): Category
  categoryByName(name: String!): Category

  # Reads and enables paginatation through a set of `DataType`.
  allDataTypes(
    # The method to use when ordering `DataType`.
    orderBy: DataTypesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: DataTypeCondition
  ): DataTypesConnection

  # Reads a single `DataType` using its globally unique `ID`.
  dataType(
    # The globally unique `ID` to be used in selecting a single `DataType`.
    nodeId: ID!
  ): DataType
  dataTypeByName(name: String!): DataType

  # Reads and enables paginatation through a set of `Object`.
  allObjects(
    # The method to use when ordering `Object`.
    orderBy: ObjectsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ObjectCondition
  ): ObjectsConnection

  # Reads a single `Object` using its globally unique `ID`.
  object(
    # The globally unique `ID` to be used in selecting a single `Object`.
    nodeId: ID!
  ): Object
  objectById(id: Uuid!): Object

  # Reads and enables paginatation through a set of `Organization`.
  allOrganizations(
    # The method to use when ordering `Organization`.
    orderBy: OrganizationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: OrganizationCondition
  ): OrganizationsConnection

  # Reads a single `Organization` using its globally unique `ID`.
  organization(
    # The globally unique `ID` to be used in selecting a single `Organization`.
    nodeId: ID!
  ): Organization
  organizationById(id: Uuid!): Organization
  organizationByName(name: String!): Organization

  # Reads and enables paginatation through a set of `OrganizationUser`.
  allOrganizationUsers(
    # The method to use when ordering `OrganizationUser`.
    orderBy: OrganizationUsersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: OrganizationUserCondition
  ): OrganizationUsersConnection

  # Reads a single `OrganizationUser` using its globally unique `ID`.
  organizationUser(
    # The globally unique `ID` to be used in selecting a single `OrganizationUser`.
    nodeId: ID!
  ): OrganizationUser
  organizationUserByOrganizationIdAndUserIdAndRole(organizationId: Uuid!, userId: Uuid!, role: String!): OrganizationUser

  # Reads and enables paginatation through a set of `PcoPropertiesByCategory`.
  allPcoPropertiesByCategories(
    # The method to use when ordering `PcoPropertiesByCategory`.
    orderBy: PcoPropertiesByCategoriesOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PcoPropertiesByCategoryCondition
  ): PcoPropertiesByCategoriesConnection

  # Reads and enables paginatation through a set of `PropertyCollection`.
  allPropertyCollections(
    # The method to use when ordering `PropertyCollection`.
    orderBy: PropertyCollectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PropertyCollectionCondition
  ): PropertyCollectionsConnection

  # Reads a single `PropertyCollection` using its globally unique `ID`.
  propertyCollection(
    # The globally unique `ID` to be used in selecting a single `PropertyCollection`.
    nodeId: ID!
  ): PropertyCollection
  propertyCollectionById(id: Uuid!): PropertyCollection
  propertyCollectionByName(name: String!): PropertyCollection

  # Reads and enables paginatation through a set of `PropertyCollectionObject`.
  allPropertyCollectionObjects(
    # The method to use when ordering `PropertyCollectionObject`.
    orderBy: PropertyCollectionObjectsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PropertyCollectionObjectCondition
  ): PropertyCollectionObjectsConnection

  # Reads a single `PropertyCollectionObject` using its globally unique `ID`.
  propertyCollectionObject(
    # The globally unique `ID` to be used in selecting a single `PropertyCollectionObject`.
    nodeId: ID!
  ): PropertyCollectionObject
  propertyCollectionObjectById(id: Uuid!): PropertyCollectionObject
  propertyCollectionObjectByObjectIdAndPropertyCollectionId(objectId: Uuid!, propertyCollectionId: Uuid!): PropertyCollectionObject

  # Reads and enables paginatation through a set of `Relation`.
  allRelations(
    # The method to use when ordering `Relation`.
    orderBy: RelationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: RelationCondition
  ): RelationsConnection

  # Reads a single `Relation` using its globally unique `ID`.
  relation(
    # The globally unique `ID` to be used in selecting a single `Relation`.
    nodeId: ID!
  ): Relation
  relationById(id: Uuid!): Relation
  relationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationType(propertyCollectionId: Uuid!, objectId: Uuid!, objectIdRelation: Uuid!, relationType: String!): Relation

  # Reads and enables paginatation through a set of `Role`.
  allRoles(
    # The method to use when ordering `Role`.
    orderBy: RolesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: RoleCondition
  ): RolesConnection

  # Reads a single `Role` using its globally unique `ID`.
  role(
    # The globally unique `ID` to be used in selecting a single `Role`.
    nodeId: ID!
  ): Role
  roleByName(name: String!): Role

  # Reads and enables paginatation through a set of `Synonym`.
  allSynonyms(
    # The method to use when ordering `Synonym`.
    orderBy: SynonymsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SynonymCondition
  ): SynonymsConnection

  # Reads a single `Synonym` using its globally unique `ID`.
  synonym(
    # The globally unique `ID` to be used in selecting a single `Synonym`.
    nodeId: ID!
  ): Synonym
  synonymByObjectIdAndObjectIdSynonym(objectId: Uuid!, objectIdSynonym: Uuid!): Synonym

  # Reads and enables paginatation through a set of `Taxonomy`.
  allTaxonomies(
    # The method to use when ordering `Taxonomy`.
    orderBy: TaxonomiesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TaxonomyCondition
  ): TaxonomiesConnection

  # Reads a single `Taxonomy` using its globally unique `ID`.
  taxonomy(
    # The globally unique `ID` to be used in selecting a single `Taxonomy`.
    nodeId: ID!
  ): Taxonomy
  taxonomyById(id: Uuid!): Taxonomy
  taxonomyByName(name: String!): Taxonomy

  # Reads and enables paginatation through a set of `User`.
  allUsers(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition
  ): UsersConnection

  # Reads a single `User` using its globally unique `ID`.
  user(
    # The globally unique `ID` to be used in selecting a single `User`.
    nodeId: ID!
  ): User
  userById(id: Uuid!): User
  userByName(name: String!): User
  userByEmail(email: String!): User

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  nodeId: ID!
}

type Relation implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Uuid!
  propertyCollectionId: Uuid!
  objectId: Uuid!
  objectIdRelation: Uuid!
  relationType: String!
  properties: Json

  # Reads a single `PropertyCollection` that is related to this `Relation`.
  propertyCollectionByPropertyCollectionId: PropertyCollection

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectIdRelation: Object
}

# A condition to be used against `Relation` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input RelationCondition {
  # Checks for equality with the object’s `id` field.
  id: Uuid

  # Checks for equality with the object’s `propertyCollectionId` field.
  propertyCollectionId: Uuid

  # Checks for equality with the object’s `objectId` field.
  objectId: Uuid

  # Checks for equality with the object’s `objectIdRelation` field.
  objectIdRelation: Uuid

  # Checks for equality with the object’s `relationType` field.
  relationType: String

  # Checks for equality with the object’s `properties` field.
  properties: Json
}

input RelationInput {
  id: Uuid
  propertyCollectionId: Uuid!
  objectId: Uuid!
  objectIdRelation: Uuid!
  relationType: String!
  properties: Json
}

# Represents an update to a `Relation`. Fields that are set will be updated.
input RelationPatch {
  id: Uuid
  propertyCollectionId: Uuid
  objectId: Uuid
  objectIdRelation: Uuid
  relationType: String
  properties: Json
}

# A connection to a list of `Relation` values.
type RelationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Relation` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Relation` and cursor to aid in pagination.
  edges: [RelationsEdge]

  # A list of `Relation` objects.
  nodes: [Relation!]
}

# A `Relation` edge in the connection.
type RelationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Relation` at the end of the edge.
  node: Relation!
}

# Methods to use when ordering `Relation`.
enum RelationsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  PROPERTY_COLLECTION_ID_ASC
  PROPERTY_COLLECTION_ID_DESC
  OBJECT_ID_ASC
  OBJECT_ID_DESC
  OBJECT_ID_RELATION_ASC
  OBJECT_ID_RELATION_DESC
  RELATION_TYPE_ASC
  RELATION_TYPE_DESC
  PROPERTIES_ASC
  PROPERTIES_DESC
}

type Role implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  name: String!
}

# A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’
input RoleCondition {
  # Checks for equality with the object’s `name` field.
  name: String
}

input RoleInput {
  name: String!
}

# Represents an update to a `Role`. Fields that are set will be updated.
input RolePatch {
  name: String
}

# A connection to a list of `Role` values.
type RolesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Role` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Role` and cursor to aid in pagination.
  edges: [RolesEdge]

  # A list of `Role` objects.
  nodes: [Role!]
}

# A `Role` edge in the connection.
type RolesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Role` at the end of the edge.
  node: Role!
}

# Methods to use when ordering `Role`.
enum RolesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  NAME_ASC
  NAME_DESC
}

type Synonym implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  objectId: Uuid!
  objectIdSynonym: Uuid!

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectIdSynonym: Object
}

# A condition to be used against `Synonym` object types. All fields are tested for equality and combined with a logical ‘and.’
input SynonymCondition {
  # Checks for equality with the object’s `objectId` field.
  objectId: Uuid

  # Checks for equality with the object’s `objectIdSynonym` field.
  objectIdSynonym: Uuid
}

input SynonymInput {
  objectId: Uuid!
  objectIdSynonym: Uuid!
}

# Represents an update to a `Synonym`. Fields that are set will be updated.
input SynonymPatch {
  objectId: Uuid
  objectIdSynonym: Uuid
}

# A connection to a list of `Synonym` values.
type SynonymsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Synonym` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Synonym` and cursor to aid in pagination.
  edges: [SynonymsEdge]

  # A list of `Synonym` objects.
  nodes: [Synonym!]
}

# A `Synonym` edge in the connection.
type SynonymsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Synonym` at the end of the edge.
  node: Synonym!
}

# Methods to use when ordering `Synonym`.
enum SynonymsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  OBJECT_ID_ASC
  OBJECT_ID_DESC
  OBJECT_ID_SYNONYM_ASC
  OBJECT_ID_SYNONYM_DESC
}

# A connection to a list of `Taxonomy` values.
type TaxonomiesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Taxonomy` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Taxonomy` and cursor to aid in pagination.
  edges: [TaxonomiesEdge]

  # A list of `Taxonomy` objects.
  nodes: [Taxonomy!]
}

# A `Taxonomy` edge in the connection.
type TaxonomiesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Taxonomy` at the end of the edge.
  node: Taxonomy!
}

# Methods to use when ordering `Taxonomy`.
enum TaxonomiesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  LINKS_ASC
  LINKS_DESC
  LAST_UPDATED_ASC
  LAST_UPDATED_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  IS_CATEGORY_STANDARD_ASC
  IS_CATEGORY_STANDARD_DESC
  IMPORTED_BY_ASC
  IMPORTED_BY_DESC
  TERMS_OF_USE_ASC
  TERMS_OF_USE_DESC
  HABITAT_LABEL_ASC
  HABITAT_LABEL_DESC
  HABITAT_COMMENTS_ASC
  HABITAT_COMMENTS_DESC
  HABITAT_NR_FNS_MIN_ASC
  HABITAT_NR_FNS_MIN_DESC
  HABITAT_NR_FNS_MAX_ASC
  HABITAT_NR_FNS_MAX_DESC
}

type Taxonomy implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Uuid!
  name: String!
  description: String
  links: [String]
  lastUpdated: Date
  organizationId: Uuid!
  isCategoryStandard: Boolean
  importedBy: Uuid!
  termsOfUse: String
  habitatLabel: String
  habitatComments: String
  habitatNrFnsMin: Int
  habitatNrFnsMax: Int

  # Reads and enables paginatation through a set of `Object`.
  objectLevel1(
    # The method to use when ordering `Object`.
    orderBy: TaxonomyObjectLevel1OrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    taxonomyId: Uuid
  ): TaxonomyObjectLevel1Connection

  # Reads a single `Organization` that is related to this `Taxonomy`.
  organizationByOrganizationId: Organization

  # Reads and enables paginatation through a set of `Object`.
  objectsByTaxonomyId(
    # The method to use when ordering `Object`.
    orderBy: ObjectsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ObjectCondition
  ): ObjectsConnection
}

# A condition to be used against `Taxonomy` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input TaxonomyCondition {
  # Checks for equality with the object’s `id` field.
  id: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `links` field.
  links: [String]

  # Checks for equality with the object’s `lastUpdated` field.
  lastUpdated: Date

  # Checks for equality with the object’s `organizationId` field.
  organizationId: Uuid

  # Checks for equality with the object’s `isCategoryStandard` field.
  isCategoryStandard: Boolean

  # Checks for equality with the object’s `importedBy` field.
  importedBy: Uuid

  # Checks for equality with the object’s `termsOfUse` field.
  termsOfUse: String

  # Checks for equality with the object’s `habitatLabel` field.
  habitatLabel: String

  # Checks for equality with the object’s `habitatComments` field.
  habitatComments: String

  # Checks for equality with the object’s `habitatNrFnsMin` field.
  habitatNrFnsMin: Int

  # Checks for equality with the object’s `habitatNrFnsMax` field.
  habitatNrFnsMax: Int
}

input TaxonomyInput {
  id: Uuid
  name: String!
  description: String
  links: [String]
  lastUpdated: Date
  organizationId: Uuid!
  isCategoryStandard: Boolean
  importedBy: Uuid!
  termsOfUse: String
  habitatLabel: String
  habitatComments: String
  habitatNrFnsMin: Int
  habitatNrFnsMax: Int
}

# A connection to a list of `Object` values.
type TaxonomyObjectLevel1Connection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Object` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Object` and cursor to aid in pagination.
  edges: [TaxonomyObjectLevel1Edge]

  # A list of `Object` objects.
  nodes: [Object]
}

# A `Object` edge in the connection.
type TaxonomyObjectLevel1Edge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Object` at the end of the edge.
  node: Object
}

# Methods to use when ordering `Object`.
enum TaxonomyObjectLevel1OrderBy {
  NATURAL
}

# Represents an update to a `Taxonomy`. Fields that are set will be updated.
input TaxonomyPatch {
  id: Uuid
  name: String
  description: String
  links: [String]
  lastUpdated: Date
  organizationId: Uuid
  isCategoryStandard: Boolean
  importedBy: Uuid
  termsOfUse: String
  habitatLabel: String
  habitatComments: String
  habitatNrFnsMin: Int
  habitatNrFnsMax: Int
}

# All input for the `updateCategoryByName` mutation.
input UpdateCategoryByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `Category` identified by our unique key.
  categoryPatch: CategoryPatch!
}

# All input for the `updateCategory` mutation.
input UpdateCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Category` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Category` identified by our globally unique `ID`.
  categoryPatch: CategoryPatch!
}

# The output of our `updateCategory` mutation.
type UpdateCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  category: Category

  # Reads a single `DataType` that is related to this `Category`.
  dataTypeByDataType: DataType

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateDataTypeByName` mutation.
input UpdateDataTypeByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `DataType` identified by our unique key.
  dataTypePatch: DataTypePatch!
}

# All input for the `updateDataType` mutation.
input UpdateDataTypeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `DataType` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `DataType` identified by our globally unique `ID`.
  dataTypePatch: DataTypePatch!
}

# The output of our `updateDataType` mutation.
type UpdateDataTypePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  dataType: DataType

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateObjectById` mutation.
input UpdateObjectByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!

  # An object where the defined keys will be set on the `Object` identified by our unique key.
  objectPatch: ObjectPatch!
}

# All input for the `updateObject` mutation.
input UpdateObjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Object` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Object` identified by our globally unique `ID`.
  objectPatch: ObjectPatch!
}

# The output of our `updateObject` mutation.
type UpdateObjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  object: Object

  # Reads a single `Taxonomy` that is related to this `Object`.
  taxonomyByTaxonomyId: Taxonomy

  # Reads a single `Object` that is related to this `Object`.
  objectByParentId: Object

  # Reads a single `Category` that is related to this `Object`.
  categoryByCategory: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateOrganizationById` mutation.
input UpdateOrganizationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!

  # An object where the defined keys will be set on the `Organization` identified by our unique key.
  organizationPatch: OrganizationPatch!
}

# All input for the `updateOrganizationByName` mutation.
input UpdateOrganizationByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `Organization` identified by our unique key.
  organizationPatch: OrganizationPatch!
}

# All input for the `updateOrganization` mutation.
input UpdateOrganizationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Organization` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Organization` identified by our globally unique `ID`.
  organizationPatch: OrganizationPatch!
}

# The output of our `updateOrganization` mutation.
type UpdateOrganizationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  organization: Organization

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateOrganizationUserByOrganizationIdAndUserIdAndRole` mutation.
input UpdateOrganizationUserByOrganizationIdAndUserIdAndRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  organizationId: Uuid!
  userId: Uuid!
  role: String!

  # An object where the defined keys will be set on the `OrganizationUser` identified by our unique key.
  organizationUserPatch: OrganizationUserPatch!
}

# All input for the `updateOrganizationUser` mutation.
input UpdateOrganizationUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `OrganizationUser` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `OrganizationUser` identified by our globally unique `ID`.
  organizationUserPatch: OrganizationUserPatch!
}

# The output of our `updateOrganizationUser` mutation.
type UpdateOrganizationUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  organizationUser: OrganizationUser

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePropertyCollectionById` mutation.
input UpdatePropertyCollectionByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!

  # An object where the defined keys will be set on the `PropertyCollection` identified by our unique key.
  propertyCollectionPatch: PropertyCollectionPatch!
}

# All input for the `updatePropertyCollectionByName` mutation.
input UpdatePropertyCollectionByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `PropertyCollection` identified by our unique key.
  propertyCollectionPatch: PropertyCollectionPatch!
}

# All input for the `updatePropertyCollection` mutation.
input UpdatePropertyCollectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PropertyCollection` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `PropertyCollection` identified by our globally unique `ID`.
  propertyCollectionPatch: PropertyCollectionPatch!
}

# All input for the `updatePropertyCollectionObjectById` mutation.
input UpdatePropertyCollectionObjectByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!

  # An object where the defined keys will be set on the `PropertyCollectionObject` identified by our unique key.
  propertyCollectionObjectPatch: PropertyCollectionObjectPatch!
}

# All input for the `updatePropertyCollectionObjectByObjectIdAndPropertyCollectionId` mutation.
input UpdatePropertyCollectionObjectByObjectIdAndPropertyCollectionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  objectId: Uuid!
  propertyCollectionId: Uuid!

  # An object where the defined keys will be set on the `PropertyCollectionObject` identified by our unique key.
  propertyCollectionObjectPatch: PropertyCollectionObjectPatch!
}

# All input for the `updatePropertyCollectionObject` mutation.
input UpdatePropertyCollectionObjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PropertyCollectionObject` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `PropertyCollectionObject` identified by our globally unique `ID`.
  propertyCollectionObjectPatch: PropertyCollectionObjectPatch!
}

# The output of our `updatePropertyCollectionObject` mutation.
type UpdatePropertyCollectionObjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  propertyCollectionObject: PropertyCollectionObject

  # Reads a single `Object` that is related to this `PropertyCollectionObject`.
  objectByObjectId: Object

  # Reads a single `PropertyCollection` that is related to this `PropertyCollectionObject`.
  propertyCollectionByPropertyCollectionId: PropertyCollection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `updatePropertyCollection` mutation.
type UpdatePropertyCollectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  propertyCollection: PropertyCollection

  # Reads a single `DataType` that is related to this `PropertyCollection`.
  dataTypeByDataType: DataType

  # Reads a single `Organization` that is related to this `PropertyCollection`.
  organizationByOrganizationId: Organization

  # Reads a single `User` that is related to this `PropertyCollection`.
  userByImportedBy: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateRelationById` mutation.
input UpdateRelationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!

  # An object where the defined keys will be set on the `Relation` identified by our unique key.
  relationPatch: RelationPatch!
}

# All input for the `updateRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationType` mutation.
input UpdateRelationByPropertyCollectionIdAndObjectIdAndObjectIdRelationAndRelationTypeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  propertyCollectionId: Uuid!
  objectId: Uuid!
  objectIdRelation: Uuid!
  relationType: String!

  # An object where the defined keys will be set on the `Relation` identified by our unique key.
  relationPatch: RelationPatch!
}

# All input for the `updateRelation` mutation.
input UpdateRelationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Relation` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Relation` identified by our globally unique `ID`.
  relationPatch: RelationPatch!
}

# The output of our `updateRelation` mutation.
type UpdateRelationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  relation: Relation

  # Reads a single `PropertyCollection` that is related to this `Relation`.
  propertyCollectionByPropertyCollectionId: PropertyCollection

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Relation`.
  objectByObjectIdRelation: Object

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateRoleByName` mutation.
input UpdateRoleByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `Role` identified by our unique key.
  rolePatch: RolePatch!
}

# All input for the `updateRole` mutation.
input UpdateRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Role` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Role` identified by our globally unique `ID`.
  rolePatch: RolePatch!
}

# The output of our `updateRole` mutation.
type UpdateRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  role: Role

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateSynonymByObjectIdAndObjectIdSynonym` mutation.
input UpdateSynonymByObjectIdAndObjectIdSynonymInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  objectId: Uuid!
  objectIdSynonym: Uuid!

  # An object where the defined keys will be set on the `Synonym` identified by our unique key.
  synonymPatch: SynonymPatch!
}

# All input for the `updateSynonym` mutation.
input UpdateSynonymInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Synonym` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Synonym` identified by our globally unique `ID`.
  synonymPatch: SynonymPatch!
}

# The output of our `updateSynonym` mutation.
type UpdateSynonymPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  synonym: Synonym

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectId: Object

  # Reads a single `Object` that is related to this `Synonym`.
  objectByObjectIdSynonym: Object

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateTaxonomyById` mutation.
input UpdateTaxonomyByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!

  # An object where the defined keys will be set on the `Taxonomy` identified by our unique key.
  taxonomyPatch: TaxonomyPatch!
}

# All input for the `updateTaxonomyByName` mutation.
input UpdateTaxonomyByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `Taxonomy` identified by our unique key.
  taxonomyPatch: TaxonomyPatch!
}

# All input for the `updateTaxonomy` mutation.
input UpdateTaxonomyInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Taxonomy` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Taxonomy` identified by our globally unique `ID`.
  taxonomyPatch: TaxonomyPatch!
}

# The output of our `updateTaxonomy` mutation.
type UpdateTaxonomyPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  taxonomy: Taxonomy

  # Reads a single `Organization` that is related to this `Taxonomy`.
  organizationByOrganizationId: Organization

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateUserByEmail` mutation.
input UpdateUserByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  email: String!

  # An object where the defined keys will be set on the `User` identified by our unique key.
  userPatch: UserPatch!
}

# All input for the `updateUserById` mutation.
input UpdateUserByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Uuid!

  # An object where the defined keys will be set on the `User` identified by our unique key.
  userPatch: UserPatch!
}

# All input for the `updateUserByName` mutation.
input UpdateUserByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `User` identified by our unique key.
  userPatch: UserPatch!
}

# All input for the `updateUser` mutation.
input UpdateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `User` identified by our globally unique `ID`.
  userPatch: UserPatch!
}

# The output of our `updateUser` mutation.
type UpdateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

type User implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Uuid!
  name: String!
  email: String!
  password: String!

  # Reads and enables paginatation through a set of `PropertyCollection`.
  propertyCollectionsByImportedBy(
    # The method to use when ordering `PropertyCollection`.
    orderBy: PropertyCollectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PropertyCollectionCondition
  ): PropertyCollectionsConnection
}

# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
input UserCondition {
  # Checks for equality with the object’s `id` field.
  id: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `password` field.
  password: String
}

input UserInput {
  id: Uuid
  name: String!
  email: String!
  password: String!
}

# Represents an update to a `User`. Fields that are set will be updated.
input UserPatch {
  id: Uuid
  name: String
  email: String
  password: String
}

# A connection to a list of `User` values.
type UsersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `User` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `User` and cursor to aid in pagination.
  edges: [UsersEdge]

  # A list of `User` objects.
  nodes: [User!]
}

# A `User` edge in the connection.
type UsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `User` at the end of the edge.
  node: User!
}

# Methods to use when ordering `User`.
enum UsersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PASSWORD_ASC
  PASSWORD_DESC
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar Uuid
